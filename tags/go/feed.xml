<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on Barbery&#39;s Blog</title>
    <link>http://barbery.me/tags/go/</link>
    <description>Recent content in Go on Barbery&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 16 Nov 2014 10:22:00 +0000</lastBuildDate>
    <atom:link href="http://barbery.me/tags/go/feed/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>goRouter 一个轻量级和高性能的路由</title>
      <link>http://barbery.me/post/2014-11-16-goRouter%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Sun, 16 Nov 2014 10:22:00 +0000</pubDate>
      
      <guid>http://barbery.me/post/2014-11-16-goRouter%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E8%B7%AF%E7%94%B1/</guid>
      <description>&lt;p&gt;公司有个go的小项目，主要是对内提供web服务，而go原生的router太弱了，上网搜索了下，本来打算用github.com/drone/routes 这个库的，但是这库对url不能很好的支持，例如要匹配/user/1/userinfo.json这样的url，这个库就没办法支持。&lt;/p&gt;

&lt;p&gt;所以自己就参考drone/routes 写了一个小router，主要是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;改善了url正则匹配的，使其匹配更多模式，更加可以自由定制&lt;/li&gt;
&lt;li&gt;提高了匹配时查找的性能，使用路由的前缀和http方法做hashtable查找，路由再多，查找平均也是o(1)的时间复杂度&lt;/ul&gt;
&amp;nbsp;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果觉得不错，欢迎star&lt;/p&gt;

&lt;p&gt;源码：&lt;a href=&#34;https://github.com/Barbery/goRouter&#34; title=&#34;https://github.com/Barbery/goRouter&#34;&gt;https://github.com/Barbery/goRouter&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>说说最近写go的感悟</title>
      <link>http://barbery.me/post/2014-10-13-%E8%AF%B4%E8%AF%B4%E6%9C%80%E8%BF%91%E5%86%99go%E7%9A%84%E6%84%9F%E6%82%9F/</link>
      <pubDate>Mon, 13 Oct 2014 22:02:00 +0000</pubDate>
      
      <guid>http://barbery.me/post/2014-10-13-%E8%AF%B4%E8%AF%B4%E6%9C%80%E8%BF%91%E5%86%99go%E7%9A%84%E6%84%9F%E6%82%9F/</guid>
      <description>&lt;p&gt;第一个，先说说GO原子性操作的问题，直接上demo（&lt;a href=&#34;https://gist.github.com/Barbery/08973672e132d5edfe44&#34; title=&#34;https://gist.github.com/Barbery/08973672e132d5edfe44&#34;&gt;https://gist.github.com/Barbery/08973672e132d5edfe44&lt;/a&gt;）：&lt;/p&gt;

&lt;p&gt;从结果可以看出，在并发编程下，常规的i++运算是不能保证原子性执行的，i++ 这样的运算会被go编译成 i = i + 1来执行，就是先读取i的值然后再加1，而go没有对share memory的操作，没有做thread safe，所以导致运算过程中读取到的i不是最新的情况，要解决这个问题有：&lt;/p&gt;

&lt;p&gt;1.加锁(可以去掉demo中的注释代码试试)&lt;/p&gt;

&lt;p&gt;2.调用atomic包来保证操作的原子性&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;第二个，就是GO和PHP的不同，GO不但作为一门后端语言，还接管了服务器，可以理解为GO是PHP+NGINX的合体。。。这样性能可以得到非常好的提升，但是也会出现不少问题。。。由于GO是常驻后台运行的，不像PHP那样通过fastcgi协议来访问，这样的区别就导致了GO中的包内/全局变量不会因为每次请求结束而销毁，导致GO的包内/全局变量就像PHP的session那样，如果同时有2个请求进来，任意一个请求改变了包内/全局变量的值都会影响另外一个请求中的值（实际上他们访问的是一个地址中的值，这和PHP很不同）。。。&lt;/p&gt;

&lt;p&gt;目前的解决办法是写成OOP的风格去做，这样做的优点是，代码上比较优雅，让每个线程调用包的时候都new一个struct对象，把全局变量包裹到struct里面，让过期是struct对象交给go的垃圾回收去处理。&lt;/p&gt;

&lt;p&gt;demo：(&lt;a href=&#34;https://gist.github.com/Barbery/173f4f3dcdfbfcc366d4&#34; title=&#34;https://gist.github.com/Barbery/173f4f3dcdfbfcc366d4&#34;&gt;https://gist.github.com/Barbery/173f4f3dcdfbfcc366d4&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;通过这样，在并发和不同线程的执行中的操作，都不会对其他线程的信息造成污染。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go-chat 用go&#43;websocket写的一个html聊天组件</title>
      <link>http://barbery.me/post/2014-08-09-go-chat%E7%94%A8go&#43;websocket%E5%86%99%E7%9A%84%E4%B8%80%E4%B8%AAhtml%E8%81%8A%E5%A4%A9%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Sat, 09 Aug 2014 16:03:00 +0000</pubDate>
      
      <guid>http://barbery.me/post/2014-08-09-go-chat%E7%94%A8go&#43;websocket%E5%86%99%E7%9A%84%E4%B8%80%E4%B8%AAhtml%E8%81%8A%E5%A4%A9%E7%BB%84%E4%BB%B6/</guid>
      <description>

&lt;p&gt;最近闲着蛋疼，就折腾下go语言。。。据说go的长连接性能异常高效。。。so，我就用go+html5的websocket搞了个聊天组件玩玩。。。&lt;/p&gt;

&lt;p&gt;经过几天的学习，我对go语言的评价是：快速，性能高效，goroutine很好用。go有着做大型项目的基因。。&lt;/p&gt;

&lt;h3 id=&#34;怎么使用&#34;&gt;怎么使用？&lt;/h3&gt;

&lt;p&gt;把下面的代码放到head标签中&lt;/p&gt;

&lt;div class=&#34;dp-highlighter&#34;&gt;
  &lt;div class=&#34;bar&#34;&gt;
  &lt;/div&gt;

&lt;p&gt;&lt;ol class=&#34;dp-xml&#34;&gt;
    &lt;li class=&#34;alt&#34;&gt;
      &lt;span&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;tag-name&#34;&gt;script&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&#34;attribute&#34;&gt;type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&#34;attribute-value&#34;&gt;&amp;ldquo;text/javascript&amp;rdquo;&lt;/span&gt;&lt;span class=&#34;tag&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp; &lt;/span&gt;&lt;/span&gt; &lt;li&gt;
        &lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span class=&#34;attribute&#34;&gt;window.onload&lt;/span&gt;&lt;span&gt; = &lt;/span&gt;&lt;span class=&#34;attribute-value&#34;&gt;function&lt;/span&gt;&lt;span&gt;() {&amp;nbsp; &lt;/span&gt;&lt;/span&gt; &lt;li class=&#34;alt&#34;&gt;
          &lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; var &lt;span class=&#34;attribute&#34;&gt;js&lt;/span&gt;&lt;span&gt; = &lt;/span&gt;&lt;span class=&#34;attribute-value&#34;&gt;document&lt;/span&gt;&lt;span&gt;.createElement(&amp;ldquo;script&amp;rdquo;);&amp;nbsp; &lt;/span&gt;&lt;/span&gt; &lt;li&gt;
            &lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span class=&#34;attribute&#34;&gt;js.type&lt;/span&gt;&lt;span&gt; = &lt;/span&gt;&lt;span class=&#34;attribute-value&#34;&gt;&amp;ldquo;text/javascript&amp;rdquo;&lt;/span&gt;&lt;span&gt;;&amp;nbsp; &lt;/span&gt;&lt;/span&gt; &lt;li class=&#34;alt&#34;&gt;
              &lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span class=&#34;attribute&#34;&gt;js.src&lt;/span&gt;&lt;span&gt; = &lt;/span&gt;&lt;span class=&#34;attribute-value&#34;&gt;&amp;ldquo;&lt;a href=&#34;http://stutostu.qiniudn.com/app.js&amp;quot;&#34;&gt;http://stutostu.qiniudn.com/app.js&amp;quot;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;;&amp;nbsp; &lt;/span&gt;&lt;/span&gt; &lt;li&gt;
                &lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; document.getElementsByTagName(&amp;ldquo;body&amp;rdquo;)[0].appendChild(js);&amp;nbsp; &lt;/span&gt; &lt;li class=&#34;alt&#34;&gt;
                  &lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; };&amp;nbsp; &lt;/span&gt; &lt;li&gt;
                    &lt;span&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;tag-name&#34;&gt;script&lt;/span&gt;&lt;span class=&#34;tag&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp; &lt;/span&gt;&lt;/span&gt;
                  &lt;/li&gt;&lt;/ol&gt; &lt;/div&gt;
                  &lt;p&gt;
                    更多引入方式，请看：&lt;a title=&#34;https://gist.github.com/Barbery/8f36d999193da2a29ab3&#34; href=&#34;https://gist.github.com/Barbery/8f36d999193da2a29ab3&#34;&gt;&lt;a href=&#34;https://gist.github.com/Barbery/8f36d999193da2a29ab3&#34;&gt;https://gist.github.com/Barbery/8f36d999193da2a29ab3&lt;/a&gt;&lt;/a&gt;
                  &lt;/p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;              &amp;lt;h3&amp;gt;
                go-chat分为4个频道，分别为：
              &amp;lt;/h3&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;strong&amp;gt;本页面&amp;lt;/strong&amp;gt;：这个频道是根据用户所在页面的url来建立的，不包括url上的？参数和#参数，即&amp;lt;a href=&amp;quot;http://stutostu.com/page1&amp;quot;&amp;gt;http://stutostu.com/page1&amp;lt;/a&amp;gt; 和 &amp;lt;a href=&amp;quot;http://stutostu.com/page1?param1=value1#aa&amp;quot;&amp;gt;http://stutostu.com/page1?param1=value1#aa&amp;lt;/a&amp;gt; 为同一个页面。使用场景：当你只想和访问这个页面的人交流的时候。
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;strong&amp;gt;本域名&amp;lt;/strong&amp;gt;：这个频道是根据用户所在页面的域名来建立的，即&amp;lt;a href=&amp;quot;http://www.stutostu.com/page1.html&amp;quot;&amp;gt;http://www.stutostu.com/page1.html&amp;lt;/a&amp;gt; 和 &amp;lt;a href=&amp;quot;http://www.stutostu.com/page2.html&amp;quot;&amp;gt;http://www.stutostu.com/page2.html&amp;lt;/a&amp;gt; 虽然所在页面不同，但是所在域名均为&amp;lt;a href=&amp;quot;http://www.stutostu.com&amp;quot;&amp;gt;www.stutostu.com&amp;lt;/a&amp;gt; ，都可以通过这个频道跨页面进行聊天。使用场景：想和同一个域名的用户交流的时候。
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;strong&amp;gt;根域名&amp;lt;/strong&amp;gt;：这个频道是根据用户所在页面的根域名来建立的，即news.stutostu.com和blog.stutostu.com的根域名均为stutostu.com，所以均可通过这个频道进行交流。使用场景：如果你想和这个站的所有人交流的时候
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;strong&amp;gt;世界&amp;lt;/strong&amp;gt;：这个范围最大。。。无论在什么页面和域名，均可通过这个频道进行交流。使用场景：如果你想和所有使用go-chat的人交流的时候
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;strong&amp;gt;注意：目前只能加入和订阅1个频道，例如你加入了世界频道，那么只能和世界频道的人进行交流，无法接收到其他频道发送的消息，也无法发送消息到其他频道。&amp;lt;/strong&amp;gt;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;amp;nbsp;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                源码: &amp;lt;a title=&amp;quot;https://github.com/Barbery/blog/tree/master/go-chat&amp;quot; href=&amp;quot;https://github.com/Barbery/blog/tree/master/go-chat&amp;quot;&amp;gt;https://github.com/Barbery/blog/tree/master/go-chat&amp;lt;/a&amp;gt;
              &amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>go多维map读写操作的问题</title>
      <link>http://barbery.me/post/2014-08-06-go%E5%A4%9A%E7%BB%B4map%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 06 Aug 2014 10:31:00 +0000</pubDate>
      
      <guid>http://barbery.me/post/2014-08-06-go%E5%A4%9A%E7%BB%B4map%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>

&lt;p&gt;因为go是静态语言，所以。。。在构造和读取多维map的操作的时候就显得木有PHP那么方便鸟，常常报错&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;cannot take the address of xxx
// or
cannot assign to xxx&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这会很让人抓狂。。&lt;/p&gt;

&lt;h3 id=&#34;关于cannot-assign-to-xxx错误&#34;&gt;关于cannot assign to xxx错误&lt;/h3&gt;

&lt;p&gt;来看代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    m := make(map[int][2]int)
    m[0] = [2]int{1, 3}
    m[0][1] = 2 //错误
    fmt.Println(m[0][1])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开这里运行: &lt;a href=&#34;http://play.golang.org/p/hMPk_N20XJ&#34;&gt;http://play.golang.org/p/hMPk_N20XJ&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;关于cannot-take-the-address-of-xxx&#34;&gt;关于cannot take the address of xxx&lt;/h3&gt;

&lt;p&gt;这个错误的原因和前面的是一致的，原因都是无法寻址&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type user struct {
    name string
    age  int
    school map[string]school
}

type school struct {
    Teacher string
    Name string
}

func main() {
    s := map[string]school{&amp;quot;primarySchool&amp;quot;:{Teacher:&amp;quot;李老师&amp;quot;, Name:&amp;quot;XX小学&amp;quot;}, &amp;quot;highSchool&amp;quot;:{Teacher:&amp;quot;曹老师&amp;quot;, Name:&amp;quot;XX中学&amp;quot;}}
    u := user{name:&amp;quot;张三&amp;quot;,age:12,school:s}
    u.school[&amp;quot;highSchool&amp;quot;].Name = &amp;quot;XX第二中学&amp;quot;//错误
    fmt.Println(u)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开这里运行：&lt;a href=&#34;http://play.golang.org/p/Jpz6ZlASTZ&#34;&gt;http://play.golang.org/p/Jpz6ZlASTZ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;原因出在user 中的 map[string]school  这里， u.school[&amp;ldquo;highSchool&amp;rdquo;] 访问到这里都没有问题，问题在于后面的 “ .Name ” ，因为map[string]school 中储存的school是数值拷贝，当要修改school里面的Name时，就发生了不可寻址的错误。&lt;/p&gt;

&lt;p&gt;正确的做法有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;重新覆盖，既然无法单独修改里面的某一项，那就全部都替换掉，u.school[&amp;ldquo;highSchool&amp;rdquo;] = school{Teacher:&amp;ldquo;曹老师&amp;rdquo;, Name:&amp;ldquo;XX第二中学&amp;rdquo;}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;改为储存指针，把map[string]school 改为 map[string]*school，把school的指针存进去，这样go就可以寻址，从而可以修改里面的值&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>