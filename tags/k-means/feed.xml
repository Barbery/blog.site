<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>K Means on Barbery&#39;s Blog</title>
    <link>http://barbery.me/tags/k-means/</link>
    <description>Recent content in K Means on Barbery&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 10 Jan 2013 16:23:00 +0000</lastBuildDate>
    <atom:link href="http://barbery.me/tags/k-means/feed/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>利用k-means聚类算法识别图片主色调</title>
      <link>http://barbery.me/post/2013-01-10-%E5%88%A9%E7%94%A8k-means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E8%AF%86%E5%88%AB%E5%9B%BE%E7%89%87%E4%B8%BB%E8%89%B2%E8%B0%83/</link>
      <pubDate>Thu, 10 Jan 2013 16:23:00 +0000</pubDate>
      
      <guid>http://barbery.me/post/2013-01-10-%E5%88%A9%E7%94%A8k-means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E8%AF%86%E5%88%AB%E5%9B%BE%E7%89%87%E4%B8%BB%E8%89%B2%E8%B0%83/</guid>
      <description>&lt;p&gt;识别图片主色调这个，网上貌似有几种方法，不过，最准确，最优雅的解决方案还是利用聚类算法来做。。。&lt;/p&gt;

&lt;p&gt;直接上代码。。。。不过，我测试结果表示，用PHP来做，效率不佳，PHP不适合做这种大规模运算~~~，用nodejs做 效率可以高出100倍左右。。。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&amp;lt;?php

$start = microtime(TRUE);
main();
function main($img = &#39;colors_files/T1OX3eXldXXXcqfYM._111424.jpg&#39;)
{
    list($width, $height, $mime_code) = getimagesize($img);
    $im  = null;
    $point = array();
    switch ($mime_code)
    {
        # jpg
        case 2:
            $im =imagecreatefromjpeg($img);
            break;

        # png
        case 3:

        default:
            exit(&#39;擦 ，什么图像？解析不了啊&#39;);
    }

    $new_width  = 100;
    $new_height = 100;
    $pixel      = imagecreatetruecolor($new_width, $new_height);
    imagecopyresampled($pixel, $im, 0, 0, 0, 0, $new_width, $new_height, $width, $height);

    run_time();
    $i = $new_width;
    while ($i--)
    {
        # reset高度
        $k = $new_height;
        while ($k--)
        {
            $rgb = ImageColorAt($im, $i, $k);
            array_push($point, array(&#39;r&#39;=&amp;gt;($rgb &amp;gt;&amp;gt; 16) &amp;amp; 0xFF, &#39;g&#39;=&amp;gt;($rgb &amp;gt;&amp;gt; 8) &amp;amp; 0xFF, &#39;b&#39;=&amp;gt;$rgb &amp;amp; 0xFF));
        }
    }
    imagedestroy($im);
    imagedestroy($pixel);

    run_time();

    $color = kmeans($point);

    run_time();

    foreach ($color as $key =&amp;gt; $value)
    {
        echo &#39;&amp;lt;br&amp;gt;&amp;lt;span style=&amp;quot;background-color:&#39; . RGBToHex($value[0]) . &#39;&amp;quot; &amp;gt;&#39; . RGBToHex($value[0]) . &#39;&amp;lt;/span&amp;gt;&#39;;
    }

}

function run_time()
{
    global $start;
    echo &#39;&amp;lt;br/&amp;gt;消耗:&#39;, microtime(TRUE) - $start;
}

function kmeans($point=array(), $k=3, $min_diff=1)
{
    global $ii;
    $point_len = count($point);
    $clusters  = array();
    $cache     = array();


    for ($i=0; $i &amp;lt; 256; $i++)
    {
        $cache[$i] = $i*$i;
    }

    # 随机生成k值
    $i = $k;
    $index = 0;
    while ($i--)
    {
        $index = mt_rand(1,$point_len-100);
        array_push($clusters, array($point[$index], array($point[$index])));
    }


    run_time();
    $point_list = array();

    $run_num = 0;

    while (TRUE)
    {
        foreach ($point as $value)
        {
            $smallest_distance = 10000000;

            # 求出距离最小的点
            # index用于保存point最靠近的k值
            $index = 0;
            $i     = $k;
            while ($i--)
            {
                $distance = 0;
                foreach ($value as $key =&amp;gt; $p1)
                {
                    if ($p1 &amp;gt; $clusters[$i][0][$key])
                    {
                        $distance += $cache[$p1 - $clusters[$i][0][$key]];
                    }
                    else
                    {
                        $distance += $cache[$clusters[$i][0][$key] - $p1];
                    }
                }

                $ii++;

                if ($distance &amp;lt; $smallest_distance)
                {
                    $smallest_distance = $distance;
                    $index = $i;
                }
            }
            $point_list[$index][] = $value;
        }

        $diff = 0;
        # 1个1个迭代k值
        $i = $k;
        while ($i--)
        {
            $old = $clusters[$i];

            # 移到到队列中心
            $center       = calculateCenter($point_list[$i], 3);
            # 形成新的k值集合队列
            $new_cluster  = array($center, $point_list[$i]);
            $clusters[$i] = $new_cluster;

            # 计算新的k值与队列所在点的位置
            $diff = euclidean($old[0], $center);
        }

        # 判断是否已足够聚合
        if ($diff &amp;lt; $min_diff)
        {
            break;   &amp;gt;
        }

    }
    echo &#39;---&amp;gt;&#39;.$ii;

    return $clusters;
}

# 计算2点距离
$ii = 0;
function euclidean($p1, $p2)
{

    $s = 0;
    foreach ($p1 as $key =&amp;gt; $value)
    {

        $temp = ($value - $p2[$key]);
        $s += $temp*$temp;
    }

    return sqrt($s);

}

# 移动k值到所有点的中心
function calculateCenter($point_list, $attr_num) {
    $vals = array();
    $point_num = 0;

    $keys = array_keys($point_list[0]);
    foreach($keys as $value)
    {
        $vals[$value] = 0;
    }

    foreach ($point_list as $arr)
    {
        $point_num++;
        foreach ($arr as $key =&amp;gt; $value)
        {
            $vals[$key] += $value;
        }
    }


    foreach ($keys as $index)
    {
        $vals[$index] = $vals[$index] / $point_num;
    }

    return $vals;
}



function RGBToHex($r, $g=&#39;&#39;, $b=&#39;&#39;)
{
    if (is_array($r))
    {
        $b = $r[&#39;b&#39;];
        $g = $r[&#39;g&#39;];

       $r = $r[&#39;r&#39;];
    }

    $hex = &amp;quot;#&amp;quot;;
    $hex.= str_pad(dechex($r), 2, &#39;0&#39;, STR_PAD_LEFT);
    $hex.= str_pad(dechex($g), 2, &#39;0&#39;, STR_PAD_LEFT);
    $hex.= str_pad(dechex($b), 2, &#39;0&#39;, STR_PAD_LEFT);

    return $hex;
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>